// Export Selection as Objective-C view

#import '../buscarini/library.js'

function dump(obj){
  log("######################################")
  log("## Dumping object " + obj )
  log("## obj class is: " + [obj className])
  log("######################################")

  log("obj.mocha:")
  log([obj class].mocha())

  log("obj.properties:")
  log([obj class].mocha().properties())
  log("obj.propertiesWithAncestors:")
  log([obj class].mocha().propertiesWithAncestors())

  log("obj.classMethods:")
  log([obj class].mocha().classMethods())
  log("obj.classMethodsWithAncestors:")
  log([obj class].mocha().classMethodsWithAncestors())

  log("obj.instanceMethods:")
  log([obj class].mocha().instanceMethods())
  log("obj.instanceMethodsWithAncestors:")
  log([obj class].mocha().instanceMethodsWithAncestors())

  log("obj.instanceVariables:")
  log([obj class].mocha().instanceVariables())


  log("obj.protocols:")
  log([obj class].mocha().protocols())
  log("obj.protocolsWithAncestors:")
  log([obj class].mocha().protocolsWithAncestors())

  log("obj.treeAsDictionary():")
  log(obj.treeAsDictionary())
}


function isGroup(layer) {
  return [layer isMemberOfClass:[MSLayerGroup class]] || [layer isMemberOfClass:[MSArtboardGroup class]]
}

function readAnimationParameters(layer) {
	var pattern = /(.*)_animation\((.*)\)/gm
	var layerName = layer.name()
	var match = pattern.exec(layerName)
	if (match==null) return null
	
	var animatedLayerName = match[1]
	var parameters = match[2]
	var paramsArray = parameters.split(",")
		
	var info = { layerName: finalLayerNameFromString(animatedLayerName) }

	var animationName = paramsArray.shift()
	var duration = paramsArray.shift()
	var repeatCount = paramsArray.shift()

	if (animationName) info.animationName = animationName
	if (duration) info.duration = duration
	if (repeatCount) info.repeatCount = repeatCount

	return info
}

function isAnimation(layer) {
	var info = readAnimationParameters(layer)
	if (info==null) return false
	return true
}

function isVisible(layer) {
	if (isAnimation(layer)) return true
	return layer.isVisible()
}

function finalLayerNameFromString(layerName) {
	var name = com.buscarini.utils.nameForVariable(layerName)
	return com.buscarini.utils.appendSuffixOnce(name,"Layer")
}

function finalLayerName(layer) {
	return finalLayerNameFromString(layer.name())
}

function finalViewName(name) {
	var viewName = com.buscarini.utils.normalizeName(name)
	return com.buscarini.utils.appendSuffixOnce(viewName,"View")
}

function firstLetterUppercase(string) {
	return string.charAt(0).toUpperCase() + string.slice(1);
}

function processLayerStyle(layerName,layer,generationInfo,classInfo) {
		
	var layerStyle = [layer style]

	var performInit = classInfo.methods["performInit"]

	if ([[layerStyle fills] count]>0) {
		var firstFill = null
		for (var fillIndex = 0; fillIndex < [[layerStyle fills] count]; fillIndex++) {
			var fill = [[layerStyle fills] objectAtIndex:fillIndex]
			if ([fill isEnabled]) {
				firstFill = fill
				break;
			}
		}
		
		if (firstFill) {
			var fillColor = [firstFill color]

			var colorString = "[UIColor colorWithRed:"+[fillColor red]+" green:"+[fillColor green]+" blue:"+[fillColor blue]+" alpha:"+[fillColor alpha]+"].CGColor"
				
			if (generationInfo.currentAnimationInfo) {
				if (generationInfo.currentAnimationInfo.fillColors[layerName]==undefined) generationInfo.currentAnimationInfo.fillColors[layerName] = []
				generationInfo.currentAnimationInfo.fillColors[layerName].push("(id)" + colorString)
			}

			performInit.body.push(
				"",
				"\tself."+layerName+".fillColor = " + colorString + ";"
			)
		}
	}

	if ([[layerStyle borders] count]>0) {
		var firstBorder = null
		for (var borderIndex = 0; borderIndex < [[layerStyle borders] count]; borderIndex++) {
			var border = [[layerStyle borders] objectAtIndex:borderIndex]
			if ([border isEnabled]) {
				firstBorder = border
				break;
			}
		}

		if (firstBorder) {
			var borderColor = [firstBorder color]
			performInit.body.push(
				"",
				"\tself."+layerName+".strokeColor = [UIColor colorWithRed:"+[borderColor red]+" green:"+[borderColor green]+" blue:"+[borderColor blue]+" alpha:"+[borderColor alpha]+"].CGColor;",
				"\tself."+layerName+".lineWidth = "+[firstBorder thickness]+";"
			)
		}
	}
	
	if ([[layerStyle shadows] count]>0) {
		var firstShadow = null
		for (var shadowIndex = 0; shadowIndex < [[layerStyle shadows] count]; shadowIndex++) {
			var shadow = [[layerStyle shadows] objectAtIndex:shadowIndex]
			if ([shadow isEnabled]) {
				firstShadow = shadow
				break;
			}
		}
			
		if (firstShadow) {
			var shadowColor = [firstShadow color]
			performInit.body.push(
				"",
				"\tself."+layerName+".shadowColor = [UIColor colorWithRed:"+[shadowColor red]+" green:"+[shadowColor green]+" blue:"+[shadowColor blue]+" alpha:"+[shadowColor alpha]+"].CGColor;",
				"\tself."+layerName+".shadowOffset = CGSizeMake("+[firstShadow offsetX]+","+[firstShadow offsetY]+");",
				"\tself."+layerName+".shadowRadius = "+[firstShadow blurRadius]+";",
				"\tself."+layerName+".shadowOpacity = 1.0;"
			)
		}
	}
	
	var opacity = [[[layer style] contextSettings] opacity]
	
	performInit.body.push(
		"",
		"\tself."+layerName+".opacity = " + opacity + ";"
	)
	
	// if ([layer isFlippedHorizontal]) {
	// 		performInit.body.push(
	// 			"",
	// 			"\tself."+layerName+".transform = CATransform3DRotate(self."+layerName+".transform,M_PI, 0, 1, 0);"
	// 		)
	// 	}
	//
	// 	if ([layer isFlippedVertical]) {
	// 		performInit.body.push(
	// 			"",
	// 			"\tself."+layerName+".transform = CATransform3DRotate(self."+layerName+".transform,M_PI, 1, 0, 0);"
	// 		)
	// 	}
}

function processPoint(layerName,index,previousPoint,point,absoluteRect,rootFrame,generationInfo,method) {

	// var proportionW = [absoluteRect width]/[rootFrame width]
// 	var proportionH = [absoluteRect height]/[rootFrame height]
//
// 	log("Proportions:" + proportionW + " " + proportionH)
//
// 	var proportion = proportionW
// 	if (proportionW>proportionH) proportion = proportionH
	
	var originX = [absoluteRect x]
	var originY = [absoluteRect y]
	
	var proportion = 1
	
	var x = (point.point().x*[absoluteRect width]+originX)*proportion
	var y = (point.point().y*[absoluteRect height]+originY)*proportion
	var controlPoint1x = (previousPoint.curveFrom().x*[absoluteRect width]+originX)*proportion
	var controlPoint1y = (previousPoint.curveFrom().y*[absoluteRect height]+originY)*proportion
	var controlPoint2x = (point.curveTo().x*[absoluteRect width]+originX)*proportion
	var controlPoint2y = (point.curveTo().y*[absoluteRect height]+originY)*proportion
	
	if (index==0) {
		method.body.push("\t["+layerName+"Path moveToPoint:CGPointMake("+x+","+y+")];")
	}
	else if (point.curveFrom() && point.curveTo()) {
		method.body.push("\t["+layerName+"Path addCurveToPoint:CGPointMake("+x+","+y+") controlPoint1:CGPointMake("+controlPoint1x+","+controlPoint1y+") controlPoint2:CGPointMake("+controlPoint2x+","+controlPoint2y+")];")
	}
	else {
		method.body.push("\t["+layerName+"Path addLineToPoint:CGPointMake("+x+","+y+")];")
	}
}

function processBezierLayerPath(layer,parentLayer,rootFrame,generationInfo,classInfo) {
	log("processing bezier layer path " + layer)
	
	if(layer && layer.isKindOfClass(MSShapePathLayer)) {

		var parentGroup = [layer parentGroup]
		var absoluteRect = [parentGroup frame]
		var layerName = finalLayerName(parentGroup)

		log("parentGroup: " + parentGroup)

		var grandpaGroup = [parentGroup parentGroup]
			
		log("grandpaGroup: " + grandpaGroup)
			
		var grandpaLayerName = finalLayerName(grandpaGroup)
			
		//layerName += firstLetterUppercase(grandpaLayerName)

		var path = layer.path()
				
		var methodName = "new"+firstLetterUppercase(layerName)
		if (!isAnimation(grandpaGroup)) methodName += firstLetterUppercase(grandpaLayerName)
		methodName += "Path"
			
		if (generationInfo.currentAnimationInfo) {
			if (generationInfo.currentAnimationInfo.paths[layerName]==undefined) generationInfo.currentAnimationInfo.paths[layerName] = []
			generationInfo.currentAnimationInfo.paths[layerName].push(methodName)			
		}
				
		var pathMethod = new Method("UIBezierPath *",methodName)
		classInfo.methods[methodName] = pathMethod
		pathMethod.body.push("\tUIBezierPath *"+layerName+"Path = [UIBezierPath bezierPath];","")

		log("processing points")

		var points = path.points()
		for (var j = 0; j < [points count]; j++) {
			
			log("processing point: " + j)

		    var point = [points objectAtIndex:j]

			var previousPoint = null				
			if (j==0) {
			    previousPoint = [points objectAtIndex:[points count]-1]
			}
			else {
			    previousPoint = [points objectAtIndex:j-1]
			}
			
			processPoint(layerName,j,previousPoint,point,absoluteRect,rootFrame,generationInfo,pathMethod)
			
			if (j==[points count]-1) {
				point = [points objectAtIndex:0]
				
			    previousPoint = [points objectAtIndex:j]
				processPoint(layerName,j,previousPoint,point,absoluteRect,rootFrame,generationInfo,pathMethod)
			}
		}
		
		pathMethod.body.push(
			"\t["+layerName+"Path closePath];",
			"",
			"\treturn "+layerName+"Path;"
		)
		
		return methodName
	}	
}

function processBezierLayer(layer,parentLayer,rootFrame,generationInfo,classInfo) {
	log("processing bezier layer " + layer)
	
	if(layer && layer.isKindOfClass(MSShapePathLayer)) {
		var parentGroup = [layer parentGroup]
		var layerName = finalLayerName(parentGroup)
		
		var frame = [parentGroup frame]
		var currentFrame = [layer frame]
		
		if (generationInfo.currentAnimationInfo) {
			processBezierLayerPath(layer,parentLayer,rootFrame,generationInfo,classInfo)
			processLayerStyle(layerName,parentGroup,generationInfo,classInfo)
		}
		else {
			generationInfo.properties.layers.push(layerName)
		
			var layerProperty = new Property("CAShapeLayer *",layerName)
			classInfo.properties[layerName] = layerProperty

			var methodName = processBezierLayerPath(layer,parentLayer,rootFrame,generationInfo,classInfo)
		
			var performInit = classInfo.methods["performInit"]
			performInit.body.push(
				"\t// " + layerName,
				"\tself."+layerName+" = [CAShapeLayer layer];",
				"\tself."+layerName+".path = [self "+methodName+"].CGPath;",
				"",
				// "\t[self.layer addSublayer:self."+layerName+"];",
				"\t["+parentLayer+" insertSublayer:self."+layerName+" atIndex:0];",
				"",
				"\tself."+layerName+".frame = CGRectMake(0,0,"+[frame width]+","+[frame height]+");",
				""
			)
		
			var layoutMethodName = "layoutLayer" + firstLetterUppercase(layerName)
			var layoutLayerView = new Method("void",layoutMethodName)
			classInfo.methods[layoutMethodName] = layoutLayerView

			var layoutSubviews = classInfo.methods["layoutSubviews"]
			layoutSubviews.body.push(
							"\t// " + layerName,
							"\t[self "+layoutMethodName+"];",
							"")
		
			layoutLayerView.body.push(
				"\tCGRect "+layerName+"BoundingBox = CGRectMake(0,0,"+[rootFrame width]+","+[rootFrame height]+");",//"CGPathGetBoundingBox(self."+layerName+".path);",
		        "\t",
				"\tCGFloat "+layerName+"BoundingBoxAspectRatio = CGRectGetWidth("+layerName+"BoundingBox)/CGRectGetHeight("+layerName+"BoundingBox);",
				"\tCGFloat "+layerName+"ViewAspectRatio = CGRectGetWidth(self.frame)/CGRectGetHeight(self.frame);",
		        "\t",
				"\tCGFloat "+layerName+"ScaleFactor = 1.0;",
				"\tif ("+layerName+"BoundingBoxAspectRatio > "+layerName+"ViewAspectRatio) {",
				"\t	"+layerName+"ScaleFactor = CGRectGetWidth(self.frame)/CGRectGetWidth("+layerName+"BoundingBox);",
				"\t} else {",
				"\t	"+layerName+"ScaleFactor = CGRectGetHeight(self.frame)/CGRectGetHeight("+layerName+"BoundingBox);",
				"\t}",
		        "\t",
		        "\t",
				"\tCGAffineTransform "+layerName+"ScaleTransform = CGAffineTransformIdentity;",
				"\t"+layerName+"ScaleTransform = CGAffineTransformScale("+layerName+"ScaleTransform, "+layerName+"ScaleFactor, "+layerName+"ScaleFactor);",
				"\t"+layerName+"ScaleTransform = CGAffineTransformTranslate("+layerName+"ScaleTransform, -CGRectGetMinX("+layerName+"BoundingBox), -CGRectGetMinY("+layerName+"BoundingBox));",
		        "\t",
				"\tCGSize "+layerName+"ScaledSize = CGSizeApplyAffineTransform("+layerName+"BoundingBox.size, CGAffineTransformMakeScale("+layerName+"ScaleFactor, "+layerName+"ScaleFactor));",
				"\tCGSize "+layerName+"CenterOffset = CGSizeMake((CGRectGetWidth(self.frame)-"+layerName+"ScaledSize.width)/("+layerName+"ScaleFactor*2.0),",
				"\t								 (CGRectGetHeight(self.frame)-"+layerName+"ScaledSize.height)/("+layerName+"ScaleFactor*2.0));",
				"\t"+layerName+"ScaleTransform = CGAffineTransformTranslate("+layerName+"ScaleTransform, "+layerName+"CenterOffset.width, "+layerName+"CenterOffset.height);",
		        "\t",
				"\tCGPathRef "+layerName+"Path = CGPathCreateCopyByTransformingPath(self."+layerName+".path,&"+layerName+"ScaleTransform);",
		        "\t",
				"\tself."+layerName+".path = "+layerName+"Path;",
		        "\t",
				"\tCGPathRelease("+layerName+"Path); ",
				""
			)
		
			processLayerStyle(layerName,parentGroup,generationInfo,classInfo)
			performInit.body.push("")
		
			return layerName
		}
	}
	
	return null
}

function processContainerLayer(layer,parentLayer,rootFrame,generationInfo,classInfo) {
	var layerName = finalLayerName(layer)
	var frame = [layer frame]
	
	var layerProperty = new Property("CALayer *",layerName)
		
	log("layer" + layer + "parentLayer" + parentLayer + "rootFrame" + rootFrame + "generationInfo" + generationInfo + "classInfo" + classInfo)
		
	classInfo.properties[layerName] = layerProperty
	
	var x = [frame x]
	var y = [frame y]
		
	if (generationInfo.currentLevel==0) {
		x = 0
		y = 0
	}
	
	var performInit = classInfo.methods["performInit"]
	
	log(classInfo.methods)
	
	performInit.body.push(
		"\t// " + layerName,
		"\tself."+layerName+" = [CALayer layer];",
		"",
		// "\t[self.layer addSublayer:self."+layerName+"];",
		"\t["+parentLayer+" insertSublayer:self."+layerName+" atIndex:0];",
		"",
		"\tself."+layerName+".frame = CGRectMake("+x+","+y+","+[frame width]+","+[frame height]+");",
		""
	)
	
	return layerName
}

function processPathAnimation(generationInfo,classInfo) {
	// Generate animations
	for (var pathKey in generationInfo.currentAnimationInfo.paths) {
	    if (generationInfo.currentAnimationInfo.paths.hasOwnProperty(pathKey)) {
			log("processing animation for path: " + pathKey)
			
			var animationValues = []
			var methodNames = generationInfo.currentAnimationInfo.paths[pathKey]
			for (var i = 0; i < methodNames.length; i++) {
				var methodName = methodNames[i]
				log("processing method: " + methodName)
				animationValues.push("(id)[self "+ methodName +"].CGPath")
			}

			var animationValuesString = animationValues.join(",")
			
			var layerName = pathKey

			var repeatCount = generationInfo.currentAnimationInfo.repeatCount
			if (repeatCount=="always" || repeatCount=="infinite") repeatCount = "HUGE_VALF"

			var animationName = layerName+"PathAnimation"

			var animationMethod = classInfo.methods[generationInfo.currentAnimationInfo.animationName]
			animationMethod.body.push(
				"\tCAKeyframeAnimation *"+animationName+" = [CAKeyframeAnimation animationWithKeyPath:@\"path\"];",
				"\t"+animationName+".duration = "+generationInfo.currentAnimationInfo.duration+";",
				"\t"+animationName+".timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];",
				"\t"+animationName+".repeatCount = "+generationInfo.currentAnimationInfo.repeatCount+";",
				"\t"+animationName+".autoreverses = YES;",
				"\t"+animationName+".values = @["+animationValuesString+"];",
				"\t[self."+layerName+" addAnimation:"+animationName+" forKey:@\"animatePath\"];",
				""
			)
		}
	}
}

function processFillColorAnimation(generationInfo,classInfo) {
	// Generate animations
	for (var colorKey in generationInfo.currentAnimationInfo.fillColors) {
	    if (generationInfo.currentAnimationInfo.paths.hasOwnProperty(colorKey)) {
			log("processing animation for fill color: " + colorKey)
			
			var animationValues = []
			var colors = generationInfo.currentAnimationInfo.fillColors[colorKey]
			for (var i = 0; i < colors.length; i++) {
				var color = colors[i]
				log("processing method: " + color)
				animationValues.push(color)
			}

			var animationValuesString = animationValues.join(",")
			
			var layerName = colorKey

			var repeatCount = generationInfo.currentAnimationInfo.repeatCount
			if (repeatCount=="always" || repeatCount=="infinite") repeatCount = "HUGE_VALF"

			var animationName = layerName+"FillColorAnimation"

			var animationMethod = classInfo.methods[generationInfo.currentAnimationInfo.animationName]
			animationMethod.body.push(
				"\tCAKeyframeAnimation *"+animationName+" = [CAKeyframeAnimation animationWithKeyPath:@\"fillColor\"];",
				"\t"+animationName+".duration = "+generationInfo.currentAnimationInfo.duration+";",
				"\t"+animationName+".timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];",
				"\t"+animationName+".repeatCount = "+generationInfo.currentAnimationInfo.repeatCount+";",
				"\t"+animationName+".autoreverses = YES;",
				"\t"+animationName+".values = @["+animationValuesString+"];",
				"\t[self."+layerName+" addAnimation:"+animationName+" forKey:@\"fillColor\"];",
				""
			)
		}
	}
}

function processLayerAnimation(layer,parentLayer,rootFrame,generationInfo,classInfo) {
	log("processing layer animation for " + layer)
		
	if (isGroup(layer)) {
		if (isAnimation(layer)) {
			generationInfo.currentAnimationInfo = readAnimationParameters(layer)
			
			var animationMethod = new IBActionMethod(generationInfo.currentAnimationInfo.animationName)
			classInfo.methods[generationInfo.currentAnimationInfo.animationName] = animationMethod
			generationInfo.animations.push(generationInfo.currentAnimationInfo.animationName)
				
			//// ONLY FOR DEBUGGING!!
			var performInit = classInfo.methods["performInit"]
			performInit.body.push("\t[self "+animationMethod.name+":self];")

			generationInfo.currentAnimationInfo.paths = {}
			generationInfo.currentAnimationInfo.opacities = {}
			generationInfo.currentAnimationInfo.fillColors = {}
			generationInfo.currentAnimationInfo.borderColors = {}
			generationInfo.currentAnimationInfo.borderWidths = {}
			generationInfo.currentAnimationInfo.shadowColors = {}

			// Process sublayers
		    var sublayers = [layer layers];
		    for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
		        var sublayer = [sublayers objectAtIndex:sub]
				generationInfo.currentLevel = generationInfo.currentLevel+1		
				processLayer(sublayer,parentLayer,rootFrame,generationInfo,classInfo)
				generationInfo.currentLevel = generationInfo.currentLevel-1
			}
			
			
			// Generate animations
			processPathAnimation(generationInfo,classInfo)
			processFillColorAnimation(generationInfo,classInfo)
			
			// for (var pathKey in generationInfo.currentAnimationInfo.paths) {
// 			    if (generationInfo.currentAnimationInfo.paths.hasOwnProperty(pathKey)) {
// 					log("processing animation for path: " + pathKey)
//
// 					var animationValues = []
// 					var methodNames = generationInfo.currentAnimationInfo.paths[pathKey]
// 					for (var i = 0; i < methodNames.length; i++) {
// 						var methodName = methodNames[i]
// 						log("processing method: " + methodName)
// 						animationValues.push("(id)[self "+ methodName +"].CGPath")
// 					}
//
// 					var animationValuesString = animationValues.join(",")
//
// 					var layerName = pathKey
//
// 					var repeatCount = generationInfo.currentAnimationInfo.repeatCount
// 					if (repeatCount=="always" || repeatCount=="infinite") repeatCount = "HUGE_VALF"
//
// 					var animationMethod = classInfo.methods[generationInfo.currentAnimationInfo.animationName]
// 					animationMethod.body.push(
// 						"\tCAKeyframeAnimation *"+layerName+"Animation = [CAKeyframeAnimation animationWithKeyPath:@\"path\"];",
// 						"\t"+layerName+"Animation.duration = "+generationInfo.currentAnimationInfo.duration+";",
// 						"\t"+layerName+"Animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];",
// 						"\t"+layerName+"Animation.repeatCount = "+generationInfo.currentAnimationInfo.repeatCount+";",
// 						"\t"+layerName+"Animation.autoreverses = YES;",
// 						"\t"+layerName+"Animation.values = @["+animationValuesString+"];",
// 						"\t[self."+layerName+" addAnimation:"+layerName+"Animation forKey:@\"animatePath\"];",
// 						""
// 					)
// 				}
// 			}
			
			generationInfo.currentAnimationInfo = null
		}
		else {
			// Process sublayers
		    var sublayers = [layer layers];
		    for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
		        var sublayer = [sublayers objectAtIndex:sub]
				generationInfo.currentLevel = generationInfo.currentLevel+1		
				processLayer(sublayer,parentLayer,rootFrame,generationInfo,classInfo)
				generationInfo.currentLevel = generationInfo.currentLevel-1
			}
		}
	}
	else {			
		processBezierLayer(layer,parentLayer,rootFrame,generationInfo,classInfo)
		// var methodName = processBezierLayerPath(layer,parentLayer,rootFrame,generationInfo,classInfo)
		
	}
}

function processLayer(layer,parentLayer,rootFrame,generationInfo,classInfo) {
	log("processing layer " + layer)

	// if (!layer || !layer.isVisible()) return
	if (!layer || !isVisible(layer)) return null
			
	if (isGroup(layer)) {
		if (isAnimation(layer) || generationInfo.currentAnimationInfo) {
			processLayerAnimation(layer,parentLayer,rootFrame,generationInfo,classInfo)
		}
		else {
			var layerName = processContainerLayer(layer,parentLayer,rootFrame,generationInfo,classInfo)
			
		    var sublayers = [layer layers];
		    for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
		        var sublayer = [sublayers objectAtIndex:sub]
				generationInfo.currentLevel = generationInfo.currentLevel+1
				processLayer(sublayer,"self."+layerName,rootFrame,generationInfo,classInfo)
				generationInfo.currentLevel = generationInfo.currentLevel-1
			}
		}
	}
	else if (layer.isKindOfClass(MSShapeGroup))  {
		sublayer = [[layer layers] objectAtIndex:0]
		generationInfo.currentLevel = generationInfo.currentLevel+1
		processLayer(sublayer,parentLayer,rootFrame,generationInfo,classInfo)
		generationInfo.currentLevel = generationInfo.currentLevel-1		
	}
	else if (layer.isKindOfClass(MSShapePathLayer)) {
		if (generationInfo.currentAnimationInfo) {
			processLayerAnimation(layer,parentLayer,rootFrame,generationInfo,classInfo)
		}
		else {
			processBezierLayer(layer,parentLayer,rootFrame,generationInfo,classInfo)		
		}
	}
}

function main() {

	if ([selection count]<=0) {
		[doc showMessage:"Nothing selected"];
	}
	else {
		var viewName = null
		if ([selection count]==1) {
			var selectedLayer = selection[0]
			viewName = finalViewName(selectedLayer.name())
		}
		else {
			// viewName = com.buscarini.utils.normalizeName([doc askForUserInput:"View class name?" initialValue:"MyView"])
			viewName = finalViewName([doc askForUserInput:"View class name?" initialValue:"MyView"])
		}
	
		var panel = [NSOpenPanel openPanel]

		[panel setAllowsMultipleSelection:false];
		[panel setCanChooseDirectories:true];
		[panel setCanChooseFiles:false];
	
		var result = [panel runModal]
		log("path choose result: " + result)
		
		if (result != NSFileHandlingPanelOKButton) return
		
		var path = [[panel URLs] lastObject];

		var generationInfo = { methods : {
									paths : {}
											},
								properties : {
									layers : []
								},
								animations : [],
								currentLevel : 0,
								currentAnimationInfo : null
							}

		var headerFile = [path URLByAppendingPathComponent:viewName + ".h"]
		var implementationFile = [path URLByAppendingPathComponent:viewName + ".m"]
		
		log("Final header and imp files: " + headerFile + " " + implementationFile)

		var classInfo = new ClassInfo(viewName)
		classInfo.parentClass = "UIView"
		classInfo.designable = true
	
		var uikitImport = new Import("UIKit/UIKit.h")
		uikitImport.relative = false
		uikitImport.public = true
		classInfo.imports["uikit"] = uikitImport
			
		var quartzCoreImport = new Import("QuartzCore/QuartzCore.h")
		quartzCoreImport.relative = false
		quartzCoreImport.public = false
		classInfo.imports["quartzCore"] = quartzCoreImport
		
		var initFrameMethod = new Method("id","initWithFrame")
		initFrameMethod.public = false
		initFrameMethod.parameters.push(new Parameter(null,"CGRect","frame"))
		initFrameMethod.body.push(
								"\tself = [super initWithFrame:frame];",
								"\tif (self) {",
								"\t\t[self performInit];",
								"\t}",
								"\treturn self;"
								)
		classInfo.methods['initFrame'] = initFrameMethod
								
		var initCoderMethod = new Method("id","initWithCoder")
		initCoderMethod.public = false
		initCoderMethod.parameters.push(new Parameter(null,"NSCoder *","aDecoder"))
		initCoderMethod.body.push(
								"\tself = [super initWithCoder:aDecoder];",
								"\tif (self) {",
								"\t\t[self performInit];",
								"\t}",
								"\treturn self;"
								)
		classInfo.methods['initCoder'] = initCoderMethod
								
		var performInitMethod = new Method("void","performInit")
		performInitMethod.public = false
		classInfo.methods['performInit'] = performInitMethod
		
		var layoutSubviewsMethod = new Method("void","layoutSubviews")
		layoutSubviewsMethod.public = false
		classInfo.methods['layoutSubviews'] = layoutSubviewsMethod

		for (var i=0; i<[selection count]; i++) {
			var layer = [selection objectAtIndex:i];
			processLayer(layer,"self.layer",layer.frame(),generationInfo,classInfo)
		}

		var header = com.buscarini.objc.generateHeader(classInfo)
		var implementation = com.buscarini.objc.generateImplementation(classInfo)
	
		log("Writing files")

		var fileManager = [NSFileManager defaultManager];
	
		var headerString = [NSString stringWithString:header]

		if ([headerString writeToURL:headerFile atomically:true encoding:NSUTF8StringEncoding error:null]) {
			var implementationString = [NSString stringWithString:implementation]
			if ([implementationString writeToURL:implementationFile atomically:true encoding:NSUTF8StringEncoding error:null]) {
				[doc showMessage:"Done"];
			}			
			else {
				[doc showMessage:"Error writing files"];				
			}
		}
		else {
			[doc showMessage:"Error writing files"];
		}
	}

}

main()

