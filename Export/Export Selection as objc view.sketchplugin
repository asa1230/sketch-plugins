// Export Selection as Objective-C view

#import '../buscarini/library.js'

function dump(obj){
  log("######################################")
  log("## Dumping object " + obj )
  log("## obj class is: " + [obj className])
  log("######################################")

  log("obj.mocha:")
  log([obj class].mocha())

  log("obj.properties:")
  log([obj class].mocha().properties())
  log("obj.propertiesWithAncestors:")
  log([obj class].mocha().propertiesWithAncestors())

  log("obj.classMethods:")
  log([obj class].mocha().classMethods())
  log("obj.classMethodsWithAncestors:")
  log([obj class].mocha().classMethodsWithAncestors())

  log("obj.instanceMethods:")
  log([obj class].mocha().instanceMethods())
  log("obj.instanceMethodsWithAncestors:")
  log([obj class].mocha().instanceMethodsWithAncestors())

  log("obj.instanceVariables:")
  log([obj class].mocha().instanceVariables())


  log("obj.protocols:")
  log([obj class].mocha().protocols())
  log("obj.protocolsWithAncestors:")
  log([obj class].mocha().protocolsWithAncestors())

  log("obj.treeAsDictionary():")
  log(obj.treeAsDictionary())
}


function isGroup(layer) {
  return [layer isMemberOfClass:[MSLayerGroup class]] || [layer isMemberOfClass:[MSArtboardGroup class]]
}

function processLayerStyle(layerName,layer,header,implementationInterface,implementation,performInit,layoutSubviews) {
		
	var layerStyle = [layer style]
				
	if ([[layerStyle fills] count]>0) {
		var firstFill = null
		for (var fillIndex = 0; fillIndex < [[layerStyle fills] count]; fillIndex++) {
			var fill = [[layerStyle fills] objectAtIndex:fillIndex]
			if ([fill isEnabled]) {
				firstFill = fill
				break;
			}
		}
		
		if (firstFill) {
			var fillColor = [firstFill color]
		
			performInit.push(
				"",
				"\tself."+layerName+".fillColor = [UIColor colorWithRed:"+[fillColor red]+" green:"+[fillColor green]+" blue:"+[fillColor blue]+" alpha:"+[fillColor alpha]+"].CGColor;"
			)
		}
	}

	if ([[layerStyle borders] count]>0) {
		var firstBorder = null
		for (var borderIndex = 0; borderIndex < [[layerStyle borders] count]; borderIndex++) {
			var border = [[layerStyle borders] objectAtIndex:borderIndex]
			if ([border isEnabled]) {
				firstBorder = border
				break;
			}
		}

		if (firstBorder) {
			var borderColor = [firstBorder color]
			performInit.push(
				"",
				"\tself."+layerName+".strokeColor = [UIColor colorWithRed:"+[borderColor red]+" green:"+[borderColor green]+" blue:"+[borderColor blue]+" alpha:"+[borderColor alpha]+"].CGColor;",
				"\tself."+layerName+".lineWidth = "+[firstBorder thickness]+";"
			)
		}
	}
	
	if ([[layerStyle shadows] count]>0) {
		var firstShadow = null
		for (var shadowIndex = 0; shadowIndex < [[layerStyle shadows] count]; shadowIndex++) {
			var shadow = [[layerStyle shadows] objectAtIndex:shadowIndex]
			if ([shadow isEnabled]) {
				firstShadow = shadow
				break;
			}
		}
			
		if (firstShadow) {
			var shadowColor = [firstShadow color]
			performInit.push(
				"",
				"\tself."+layerName+".shadowColor = [UIColor colorWithRed:"+[shadowColor red]+" green:"+[shadowColor green]+" blue:"+[shadowColor blue]+" alpha:"+[shadowColor alpha]+"].CGColor;",
				"\tself."+layerName+".shadowOffset = CGSizeMake("+[firstShadow offsetX]+","+-[firstShadow offsetY]+");",
				"\tself."+layerName+".shadowRadius = "+[firstShadow blurRadius]+";",
				"\tself."+layerName+".shadowOpacity = 1.0;"
			)
		}
	}
		
	var opacity = [[[layer style] contextSettings] opacity]
	
	performInit.push(
		"",
		"\tself."+layerName+".opacity = " + opacity + ";"
	)
}

function processPoint(layerName,index,previousPoint,point,absoluteRect,rootFrame,header,implementationInterface,implementation,performInit,layoutSubviews) {

	// var proportionW = [absoluteRect width]/[rootFrame width]
// 	var proportionH = [absoluteRect height]/[rootFrame height]
//
// 	log("Proportions:" + proportionW + " " + proportionH)
//
// 	var proportion = proportionW
// 	if (proportionW>proportionH) proportion = proportionH
	
	var proportion = 1
	
	var x = (point.point().x*[absoluteRect width]+[absoluteRect x])*proportion
	var y = (point.point().y*[absoluteRect height]+[absoluteRect y])*proportion
	var controlPoint1x = (previousPoint.curveFrom().x*[absoluteRect width]+[absoluteRect x])*proportion
	var controlPoint1y = (previousPoint.curveFrom().y*[absoluteRect height]+[absoluteRect y])*proportion
	var controlPoint2x = (point.curveTo().x*[absoluteRect width]+[absoluteRect x])*proportion
	var controlPoint2y = (point.curveTo().y*[absoluteRect height]+[absoluteRect y])*proportion
	
	if (index==0) {
		performInit.push("\t["+layerName+"Path moveToPoint:CGPointMake("+x+","+y+")];")
	}
	else if (point.curveFrom() && point.curveTo()) {
		performInit.push("\t["+layerName+"Path addCurveToPoint:CGPointMake("+x+","+y+") controlPoint1:CGPointMake("+controlPoint1x+","+controlPoint1y+") controlPoint2:CGPointMake("+controlPoint2x+","+controlPoint2y+")];")
	}
	else {
		performInit.push("\t["+layerName+"Path addLineToPoint:CGPointMake("+x+","+y+")];")
	}
}

function processBezierLayer(layer,rootFrame,header,implementationInterface,implementation,performInit,layoutSubviews) {
	log("processing bezier layer " + layer)
	
	if(layer && layer.isKindOfClass(MSShapePathLayer)) {

		var parentLayer = [layer parentGroup]
		var absoluteRect = [parentLayer frame]
			
		var layerName = com.buscarini.nameForVariable(parentLayer.name()) + "Layer"

		var path = layer.path()
			
		log("absoluteRect: " + [absoluteRect x] + " " + [absoluteRect y] + " " + [absoluteRect width] + " " + [absoluteRect height])
		
		implementationInterface.push(
			"@property (nonatomic, strong) CAShapeLayer *" + layerName + ";"
		)
		
		performInit.push(
			"\tself."+layerName+" = [CAShapeLayer layer];",
			"\tUIBezierPath *"+layerName+"Path = [UIBezierPath bezierPath];",
			""
		)

		log("processing points")

		var points = path.points()
		for (var j = 0; j < [points count]; j++) {
			
			log("processing point: " + j)

		    var point = [points objectAtIndex:j]

			var previousPoint = null				
			if (j==0) {
			    previousPoint = [points objectAtIndex:[points count]-1]
			}
			else {
			    previousPoint = [points objectAtIndex:j-1]
			}
			
			processPoint(layerName,j,previousPoint,point,absoluteRect,rootFrame,header,implementationInterface,implementation,performInit,layoutSubviews)
			
			if (j==[points count]-1) {
				point = [points objectAtIndex:0]
				
			    previousPoint = [points objectAtIndex:j]
				processPoint(layerName,j,previousPoint,point,absoluteRect,rootFrame,header,implementationInterface,implementation,performInit,layoutSubviews)
			}
		}
		
		performInit.push(
			"\t["+layerName+"Path closePath];",
			"",
			"\tself."+layerName+".path = "+layerName+"Path.CGPath;",
			"",
			"\t[self.layer insertSublayer:self."+layerName+" atIndex:0];"
		)
		
		layoutSubviews.push(
			"// " + layerName,
			"\tCGRect "+layerName+"BoundingBox = CGPathGetBoundingBox(self."+layerName+".path);",
	        "\t",
			"\tCGFloat "+layerName+"BoundingBoxAspectRatio = CGRectGetWidth("+layerName+"BoundingBox)/CGRectGetHeight("+layerName+"BoundingBox);",
			"\tCGFloat "+layerName+"ViewAspectRatio = CGRectGetWidth(self.frame)/CGRectGetHeight(self.frame);",
	        "\t",
			"\tCGFloat "+layerName+"ScaleFactor = 1.0;",
			"\tif ("+layerName+"BoundingBoxAspectRatio > "+layerName+"ViewAspectRatio) {",
			"\t	"+layerName+"ScaleFactor = CGRectGetWidth(self.frame)/CGRectGetWidth("+layerName+"BoundingBox);",
			"\t} else {",
			"\t	"+layerName+"ScaleFactor = CGRectGetHeight(self.frame)/CGRectGetHeight("+layerName+"BoundingBox);",
			"\t}",
	        "\t",
	        "\t",
			"\tCGAffineTransform "+layerName+"ScaleTransform = CGAffineTransformIdentity;",
			"\t"+layerName+"ScaleTransform = CGAffineTransformScale("+layerName+"ScaleTransform, "+layerName+"ScaleFactor, "+layerName+"ScaleFactor);",
			"\t"+layerName+"ScaleTransform = CGAffineTransformTranslate("+layerName+"ScaleTransform, -CGRectGetMinX("+layerName+"BoundingBox), -CGRectGetMinY("+layerName+"BoundingBox));",
	        "\t",
			"\tCGSize "+layerName+"ScaledSize = CGSizeApplyAffineTransform("+layerName+"BoundingBox.size, CGAffineTransformMakeScale("+layerName+"ScaleFactor, "+layerName+"ScaleFactor));",
			"\tCGSize "+layerName+"CenterOffset = CGSizeMake((CGRectGetWidth(self.frame)-"+layerName+"ScaledSize.width)/("+layerName+"ScaleFactor*2.0),",
			"\t								 (CGRectGetHeight(self.frame)-"+layerName+"ScaledSize.height)/("+layerName+"ScaleFactor*2.0));",
			"\t"+layerName+"ScaleTransform = CGAffineTransformTranslate("+layerName+"ScaleTransform, "+layerName+"CenterOffset.width, "+layerName+"CenterOffset.height);",
	        "\t",
			"\tCGPathRef "+layerName+"Path = CGPathCreateCopyByTransformingPath(self."+layerName+".path,&"+layerName+"ScaleTransform);",
	        "\t",
			"\tself."+layerName+".path = "+layerName+"Path;",
	        "\t",
			"\tCGPathRelease("+layerName+"Path); ",
			""
		)
		
		processLayerStyle(layerName,parentLayer,header,implementationInterface,implementation,performInit,layoutSubviews)
	}
}

function processLayer(layer,rootFrame,header,implementationInterface,implementation,performInit,layoutSubviews) {
	log("processing layer " + layer)

	if (!layer || !layer.isVisible()) return
			
	if (isGroup(layer)) {
	    var sublayers = [layer layers];
	    for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
	        var sublayer = [sublayers objectAtIndex:sub]
			processLayer(sublayer,rootFrame,header,implementationInterface,implementation,performInit,layoutSubviews)
		}
	}
	else if (layer.isKindOfClass(MSShapeGroup))  {
		sublayer = [[layer layers] objectAtIndex:0]
		processLayer(sublayer,rootFrame,header,implementationInterface,implementation,performInit,layoutSubviews)
	}
	else if (layer.isKindOfClass(MSShapePathLayer)) {
		processBezierLayer(layer,rootFrame,header,implementationInterface,implementation,performInit,layoutSubviews)
	}
}

if ([selection count]<=0) {
	[doc showMessage:"Nothing selected"];
}
else {
	var viewName = null
	if ([selection count]==1) {
		var selectedLayer = selection[0]
		viewName = com.buscarini.normalizeName(selectedLayer.name())
	}
	else {
		viewName = com.buscarini.normalizeName([doc askForUserInput:"View class name?" initialValue:"MyView"])
	}
	
	var panel = [NSOpenPanel openPanel]
		log("panel " + panel)
	[panel setAllowsMultipleSelection:false];
	[panel setCanChooseDirectories:true];
	[panel setCanChooseFiles:false];
	
	var result = [panel runModal]
	log("path choose result: " + result)
		
	if (result == NSFileHandlingPanelOKButton) {
		var path = [[panel URLs] lastObject];
	
		var headerFile = [path URLByAppendingPathComponent:viewName + ".h"]
		var implementationFile = [path URLByAppendingPathComponent:viewName + ".m"]
			
		log("Final header and imp files: " + headerFile + " " + implementationFile)

		var header = [	""
								,"#import <UIKit/UIKit.h>",
								"",
								"IB_DESIGNABLE",
								"@interface " + viewName + " : UIView",
								""
						]
						
		var implementationInterface = [
								"#import \"" + viewName + ".h\"",
								"",
								"#import <QuartzCore/QuartzCore.h>",
								"",
								"@interface " + viewName + "()",
								""
		]

		var implementation = [ 	"@end",
								"",
								"@implementation "+viewName+"",
								"",
								"- (id)initWithFrame:(CGRect)frame",
								"{",
								"\tself = [super initWithFrame:frame];",
								"\tif (self) {",
								"\t\t[self performInit];",
								"\t}",
								"\treturn self;",
								"}",
								"",
								"- (id)initWithCoder:(NSCoder *)aDecoder",
								"{",
								"\tself = [super initWithCoder:aDecoder];",
								"\tif (self) {",
								"\t\t[self performInit];",
								"\t}",
								"\treturn self;",
								"}",
								""
								]

		var performInit = [
			"- (void) performInit {"	
		]
		
		var layoutSubviews = [
			"- (void) layoutSubviews {"
		]

		for (var i=0; i<[selection count]; i++) {
			var layer = [selection objectAtIndex:i];
			processLayer(layer,layer.frame(),header,implementationInterface,implementation,performInit,layoutSubviews)
		}
	
		header.push("@end")
		header.push("")
	
		implementationInterface.push("")
	
		implementation = implementationInterface.concat(implementation)
		
		performInit.push("}","")
		layoutSubviews.push("}","")
		
		implementation = implementation.concat(performInit,layoutSubviews)
		// implementation = implementation.concat(implementation,layoutSubviews)
		
		// implementation.push("}")
		implementation.push("")
		implementation.push("@end")
		implementation.push("")

		log("Writing files")

		var fileManager = [NSFileManager defaultManager];
	
		header = header.join('\n')
		implementation = implementation.join('\n')
		
		var headerString = [NSString stringWithString:header]

		if ([headerString writeToURL:headerFile atomically:true encoding:NSUTF8StringEncoding error:null]) {
			var implementationString = [NSString stringWithString:implementation]
			if ([implementationString writeToURL:implementationFile atomically:true encoding:NSUTF8StringEncoding error:null]) {
				[doc showMessage:"Done"];
			}			
			else {
				[doc showMessage:"Error writing files"];				
			}
		}
		else {
			[doc showMessage:"Error writing files"];
		}
	}
}